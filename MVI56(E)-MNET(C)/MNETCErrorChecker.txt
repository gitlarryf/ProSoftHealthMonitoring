////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Routine: MNETCErrorChecker
//  Author : Larry Frieson
//  Desc   : Small Routine that checks the error status of an MNETC or MNETCR module, and sets the ModbusErrors tag accordingly.
//  Date   : 03/08/2021
//  Tags   : MonitorMNETC     - Bool: A flag indicating if we should even be performing error checking or not.  (Controller Scope)
//           MNETCError       - INT: Contains the logical OR value of all command errors. (Controller Scope)
//           CurrentClient    - INT: Current Client to process. (Local Program Scope)
//           CurrCommand      - INT: The index of the command being checked. (Local Program Scope)
//           CmdErrPtr[30]    - INT: The value of the Command Error Pointer in PCB for each client. (Local Program Scope)
//        or CmdErrPtr        - INT: Single value of the first Command Error Pointer in PCB; if using the second method below.
//           CmdErrPtrLen[30] - INT: The length of the CommandErrPtr.  (How many index's do we read--how many commands does this
//                                  client actually contain. (Local Program Scope) (N/A if using the second method below.)
//           ClientErrors[30] - INT: A an array to store the client error calculations.
//           ClientInError[30]- Bool: A boolean array to indicate which client, if any, are in an error state.
//           FlexIO           - (UDT: FlexOutput): UDT of booleans to control a FlexIO 1794-OB8 module.
//
//  Copyright © 2021 ProSoft Technology, Inc.  All rights reserved.
//
//  Revision History: 
//    08/28/2018 17:05:09 created.
//    07/09/2020 11:15:16 Added Global Monitor flag MonitorMNETC
//    03/06/2023 10:23:34 Added second (optional) check routine example
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reset our error flag
MNETCError := 0;
FlexIO.ModbusErrorIndicator := 0;

// Exit routine if we don't want to monitor the errors.
IF NOT MonitorMNETC THEN
    RET(0);
END_IF;

// Process each client one by one, checking for errors.
FOR CurrentClient := 0 TO NumberOfClients -1 DO
    ClientErrors[CurrentClient] := 0;
    // Prevent a fault in the controller if the CommandIndex + CommandErrLen is greater than ReadData array.
    IF CmdErrPtr[CurrentClient] + CmdErrPtrLen[CurrentClient] > MNETC.UTIL.ReadDataSizeGet THEN
        ClientErrors[CurrentClient] := 9999; // Prevent Controller fault by not even processing this client!
        // Bail out of this entire subroutine.  This can be enhanced, to say, force the error lights ON, or 
        // remove this check to allow it to go ahead and fault the controller.
        RET(-1);
    END_IF;

    // Go through the ReadData array checking for errors, starting at the CmdErrPtr[CurrentClient] index, for CmdErrPtrLen[CurrentClient] indices.
    FOR CurrentCommand := CmdErrPtr[CurrentClient] TO (CmdErrPtr[CurrentClient] + CmdErrPtrLen[CurrentClient]) - 1 DO
        // Perform a logical OR on all of the command errors.  If there are none, we'll end up with 0 at the end.  If there
        // are any errors whatsoever, we'll end up with SOME sort of value other than zero.
        ClientErrors[CurrentClient] := (ClientErrors[CurrentClient] OR MNETC.DATA.ReadData[CurrentCommand]);
    END_FOR;
    IF ClientErrors[CurrentClient] <> 0 THEN
        ClientInError[CurrentClient] := 1;
    ELSE
        CLientInError[CurrentClient] := 0;
    END_IF;
END_FOR;
/*
// Process each client one by one, checking for errors.  In this method, we use a single CmdErrPtr tag to store our starting pointer.  Say, 500
// a reasonable default for an MNETC.  This would be the value you enter in PCB, under Client 0, Command Error Pointer.  In Client 1, you'd enter
// a value of 516, Client 2 532, Client 3, 548 and so on.  We calculate the ReadData element by using the simple formula
// CurErrPtr = (ClientNum * 16) + StartingCommandErrorPointer
// This eliminates the need for an array to hold the starting Error Pointers for every client as well as length of each, and just assumes 16.  If
// you're only using less than 8 commands per client, then the above method might be better for you, plus you can place each command error array
// wherever you like in the ReadData, and size it accordingly.  This method below assumes one giant section for all 30 clients, but will only walk
// until it walks off the end of the ReadData array, so this method requires that you place the Command Err Ptr at the END of your ReadData.  In the
// example we started at 500.  So that means that we can handle 6 clients only!  On the 7th client, we'd walk off the end after the 4th command!  So,
// the code protects itself by returning before processing the 7th client.
FOR CurrentClient := 0 TO 29 DO
    ClientErrors[CurrentClient] := 0;
    // Prevent a fault in the controller if the CommandIndex + CommandErrLen is greater than ReadData array.
    IF CmdPtrErr + (CurrentClient * 16) > MNETC.UTIL.ReadDataSizeGet THEN
        ClientErrors[CurrentClient] := 9999; // Prevent Controller fault by not even processing this client!
        // Bail out of this entire subroutine.  This can be enhanced, to say, force the error lights ON, or
        // remove this check to allow it to go ahead and fault the controller.
        RET(-1);
    END_IF;

    // Go through the ReadData array checking for errors, starting at the CmdErrPtr[CurrentClient] index, for CmdErrPtrLen[CurrentClient] indices.
    FOR CurrentCommand := CmdPtrErr + (CurrentClient * 16) TO CmdPtrErr + (CurrentClient * 16) + 15 DO
        // Perform a logical OR on all of the command errors.  If there are none, we'll end up with 0 at the end.  If there
        // are any errors whatsoever, we'll end up with SOME sort of value other than zero.
        ClientErrors[CurrentClient] := (ClientErrors[CurrentClient] OR MNETC.DATA.ReadData[CurrentCommand]);
    END_FOR;
    IF ClientErrors[CurrentClient] <> 0 THEN
        ClientInError[CurrentClient] := 1;
    ELSE
        CLientInError[CurrentClient] := 0;
    END_IF;
END_FOR;
*/

// Do what you need to do to process your errors.
// Set Stack light indicating which client is in error.
// We start by assuming that none of the clients are in error--so we set the GREEN light to ON.
FlexIO.ModbusGoodIndicator := 1;
FOR CurrentClient := 0 TO NumberOfClients -1 DO
    IF ClientErrors[CurrentClient] = 0 THEN
        // Set the proper LED Error indicators for our 1794-OB8.  NO errors reported, so toggle the
        // LED to Green, and turn off the red LED.
        FlexIO.ModbusErrorIndicator := 0;
    ELSE
        // Set the proper LED Error indicators for our 1794-OB8.  In this case, we have errors to report.
        FlexIO.ModbusErrorIndicator := 1;
        FlexIO.ModbusGoodIndicator := 0;
        // Bail out of the loop, we discovered that a client is in error--there's no point in continuing to process
        // error values, as other clients might cause the RED light to go out.
        EXIT;
    END_IF;
END_FOR;
